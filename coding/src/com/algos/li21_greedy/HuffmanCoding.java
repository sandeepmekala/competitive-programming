package  com.algos.li21_greedy;

import java.util.PriorityQueue;

import  com.algos.li30_model.HuffmanNode;

public class HuffmanCoding {
	public static void main(String[] args) {
		HuffmanCoding obj = new HuffmanCoding();

		char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' };
		int[] charfreq = { 5, 9, 12, 13, 16, 45 };

		HuffmanNode root = obj.buildHuffmanTree(charArray, charfreq);
		obj.printCode(root, "");
	}

	// Idea: insert the input to min heap so that min retrieval is optimal once the tree is built, take the last 2 mins and create new internal node by
	// summing their frequency and then insert it back to min heap until only last node left in tree which is the root of the tree
	// O(nlogn) extract min(logn) is called 2*(n-1) times
	private HuffmanNode buildHuffmanTree(char[] charArray, int[] charfreq) {
		int n = charArray.length;
		// makes a min-priority queue(min-heap).
		PriorityQueue<HuffmanNode> queue = new PriorityQueue<HuffmanNode>(n);

		for (int i = 0; i < n; i++) {
			// creating a Huffman node object and add it to the priority queue.
			HuffmanNode node = new HuffmanNode();

			node.ch = charArray[i];
			node.freq = charfreq[i];

			node.left = null;
			node.right = null;

			queue.add(node);
		}

		HuffmanNode root = null;

		while (queue.size() > 1) {

			HuffmanNode min1 = queue.poll();
			HuffmanNode min2 = queue.poll();

			HuffmanNode internalNode = new HuffmanNode();
			internalNode.freq = min1.freq + min2.freq;
			internalNode.ch = '-';
			internalNode.left = min1;
			internalNode.right = min2;

			root = internalNode;
			queue.add(internalNode);
		}
		return root;
	}

	public void printCode(HuffmanNode root, String code) {
		// base case; if the left and right are null then its a leaf node and we print the code s generated by traversing the tree.
		if (root.left == null && root.right == null) {
			System.out.println(root.ch + ":" + code);
			return;
		}

		printCode(root.left, code + "0");
		printCode(root.right, code + "1");
	}
}